<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python IO 优化</title>
    <link href="/2023/03/23/python_IO_%E4%BC%98%E5%8C%96/"/>
    <url>/2023/03/23/python_IO_%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>python IO 优化</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="built_in">int</span>(<span class="number">1e7</span>))</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="built_in">print</span> = sys.stdout.write</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python, IO, 优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>裁剪序列 (线段树优化Dp) From 算法进阶指南</title>
    <link href="/2023/03/23/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97_%E8%A3%81%E5%89%AA%E5%BA%8F%E5%88%97/"/>
    <url>/2023/03/23/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97_%E8%A3%81%E5%89%AA%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>线段树优化dp</p><span id="more"></span><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.acwing.com/problem/content/description/301/">https://www.acwing.com/problem/content/description/301/</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$~~~~$给定一个长度为 $N$ 的序列 $A$，要求把该序列分成若干段，在满足每段中所有数的和不超过 $M$ 的前提下，让每段中所有数的最大值之和最小。<br>$~~~~$试计算这个最小值。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$~~~~$考虑 $DP$。<br>$~~~~$设状态：<br>$$<br>f[i]：前 i 个数中每段中所有数的最大值之和的最小值， i \in [1, n]<br>$$<br>$~~~~$ 对于 $i$，枚举它转移的上一个答案 $f[j]$，更新为 $i$ 前面的若干个数（满足 $\sum_{k&#x3D;j+1}^{i} a[k] &lt;&#x3D; M$）中的最大值，取最小值。<br>$~~~~$ 即状态转移方程为：<br>$$<br>f[i] &#x3D; \min{f[j] + \max{a[j+1], a[j+2], …, a[i]}}, 其中j \in [1, i], \sum_{k&#x3D;j+1}^{i} a[k] &lt;&#x3D; M<br>$$<br>$~~~~$ 注意到<br>$$<br>\max{a[i]} &lt;&#x3D; \max{a[i], a[i-1]} &lt;&#x3D; … &lt;&#x3D; \max{a[j+1], a[j+2], …, a[i]}<br>$$<br>$~~~~$ 因此对于每一个 $i$，可以用单调栈找到  $&gt;a[i]$ 的第一个数 $a[pre[i]]$，维护 $i$ 之前 $\le a[i]$ 的一段连续的区间 $[pre[i]+1, i]$，这段区间的最大值即为 $a[i]$。<br>$~~~~$ 考虑线段树优化，对于 $i$，由于 $f[i]$ 是固定的，因此  </p><ul><li>将 $f[i]$ 赋给线段树的第 $i$ 位  </li><li>在由单调栈维护出来的区间 $[pre[i]+1, i]$ 加上 $a[i]$  </li><li>使用二分找到满足 $\sum_{k&#x3D;j+1}^{i} a[k] &lt;&#x3D; M$ 的 $j$  </li><li>$f[i] &#x3D; query(j+1, i)$</li></ul><h2 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="built_in">int</span>(<span class="number">1e7</span>))</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="built_in">print</span> = sys.stdout.write</span><br><span class="line">n, L = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">inf = <span class="built_in">int</span>(<span class="number">1e18</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, l=<span class="number">0</span>, r=<span class="number">0</span>, v=inf, mn=inf, add=inf</span>):</span><br><span class="line">        self.l, self.r, self.v, self.mn, self.add = l, r, v, mn, add</span><br><span class="line">tr = [Node() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="number">1e5</span>)&lt;&lt;<span class="number">2</span>)]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">return</span> u &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rs</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">return</span> u &lt;&lt; <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mid</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">return</span> tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    tr[u] = Node(l, r)</span><br><span class="line">    <span class="keyword">if</span> l == r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    build(ls(u), l, mid(u))</span><br><span class="line">    build(rs(u), mid(u)+<span class="number">1</span>, r)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pushup</span>(<span class="params">u</span>):</span><br><span class="line">    tr[u].mn = <span class="built_in">min</span>(tr[ls(u)].mn, tr[rs(u)].mn)</span><br><span class="line">    tr[u].v = <span class="built_in">min</span>(tr[ls(u)].v, tr[rs(u)].v)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pushdown</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="keyword">if</span> tr[u].add != inf:</span><br><span class="line">        tr[ls(u)].mn = tr[ls(u)].v + tr[u].add</span><br><span class="line">        tr[rs(u)].mn = tr[rs(u)].v + tr[u].add</span><br><span class="line">        tr[ls(u)].add = tr[u].add</span><br><span class="line">        tr[rs(u)].add = tr[u].add</span><br><span class="line">        tr[u].add = inf</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">u, x, v</span>):</span><br><span class="line">    <span class="keyword">if</span> tr[u].l == tr[u].r:</span><br><span class="line">        tr[u].mn = inf</span><br><span class="line">        tr[u].v = v</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pushdown(u)</span><br><span class="line">    <span class="keyword">if</span> x &lt;= mid(u):</span><br><span class="line">        change(ls(u), x, v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        change(rs(u), x, v)</span><br><span class="line">    pushup(u)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">u, l, r, v</span>):</span><br><span class="line">    <span class="keyword">if</span> l &lt;= tr[u].l <span class="keyword">and</span> tr[u].r &lt;= r:</span><br><span class="line">        tr[u].mn = tr[u].v + v</span><br><span class="line">        tr[u].add = v</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pushdown(u)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= mid(u):</span><br><span class="line">        update(ls(u), l, r, v)</span><br><span class="line">    <span class="keyword">if</span> r &gt; mid(u):</span><br><span class="line">        update(rs(u), l, r, v)</span><br><span class="line">    pushup(u)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &lt;= tr[u].l <span class="keyword">and</span> tr[u].r &lt;= r:</span><br><span class="line">        <span class="keyword">return</span> tr[u].mn</span><br><span class="line">    res = inf</span><br><span class="line">    pushdown(u)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= mid(u):</span><br><span class="line">        res = <span class="built_in">min</span>(res, query(ls(u), l, r))</span><br><span class="line">    <span class="keyword">if</span> r &gt; mid(u):</span><br><span class="line">        res = <span class="built_in">min</span>(res, query(rs(u), l, r))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">h = [<span class="number">0</span>] + [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">sw = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    sw[i] = sw[i-<span class="number">1</span>] + h[i]</span><br><span class="line">stk = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">top = <span class="number">1</span></span><br><span class="line">stk[top] = <span class="number">1</span></span><br><span class="line">pre = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">while</span> top &gt; <span class="number">0</span> <span class="keyword">and</span> h[stk[top]] &lt;= h[i]:</span><br><span class="line">        top -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> top &gt; <span class="number">0</span>:</span><br><span class="line">        pre[i] = stk[top]</span><br><span class="line">    top += <span class="number">1</span></span><br><span class="line">    stk[top] = i</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sw[mid] &gt;= x:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    change(<span class="number">1</span>, i, f[i-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> pre[i] + <span class="number">1</span> &lt;= i:</span><br><span class="line">        update(<span class="number">1</span>, pre[i] + <span class="number">1</span>, i, h[i])</span><br><span class="line">    left = lower_bound(<span class="number">0</span>, i, sw[i] - L)</span><br><span class="line">    <span class="keyword">if</span> left &lt; i:</span><br><span class="line">        f[i] = query(<span class="number">1</span>, left+<span class="number">1</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%d\n&#x27;</span> % f[n])</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>裁剪序列, 算法进阶指南, 线段树, DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nebius Welcome Round (Div. 1 + Div. 2) a - D</title>
    <link href="/2023/03/20/cf_1804/"/>
    <url>/2023/03/20/cf_1804/</url>
    
    <content type="html"><![CDATA[<p>A (思维) B (贪心) C (数论) D (贪心)</p><span id="more"></span><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/contest/1804">https://codeforces.com/contest/1804</a></p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$ 从 $(0, 0)$ 开始走，每次只能走上下左右四个方向，走一步，且方向和上一次不同，问走到 $(a, b)$ 最短步数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$ 一般地，将 $(0, 0)$ 和 $(a, b)(a &lt; b \ and \ a &gt; 0 \ and \ b &gt; 0)$ 视为长方形的两个顶点，则最优策略是从 $(0, 0)$ 走到 $(a, a)$，在从 $(a, a)$ 走到 $(a, b)$。<br>$~~~~$ 则答案为 $2 * (b - a) - 1$</p><h3 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    x, y = [<span class="built_in">abs</span>(<span class="built_in">int</span>(_)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        x, y = y, x</span><br><span class="line">    res = <span class="number">2</span> * x</span><br><span class="line">    <span class="keyword">if</span> y &gt; x:</span><br><span class="line">        res+=<span class="number">2</span> * (y-x)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$ 给出一些区间 $[t_{i}, t_{i}+w], t_{i} \le t_{i+1},i \in [1, n]$，要求使用数量最少的个区间 $[x, x+w]$，其中 $x$ 自定，使得所有的区间和 $[x, x+w]$ 有交集。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$ 考虑贪心。从前往后遍历 $t_{i}$，以 $t_{i} + w$ 作为左边界，$t_{i} + w+d$ 作为右边界，寻找和该区间相交的区间，直到下一个区间不再与该区间相交，则另起一个新的区间。</p><h3 id="python-代码-1"><a href="#python-代码-1" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, k, d, w = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    a = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    right = -<span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    nowk = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> a[i] &lt;= right <span class="keyword">and</span> nowk:</span><br><span class="line">            nowk -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            right = a[i] + w + d</span><br><span class="line">            nowk = k - <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$ 找到一个 $f, f \in [1, p]$，使得 $(x + \frac{f * (f + 1)}{2}) % n &#x3D;&#x3D; 0$ 成立。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$ 上结论，<br>$$<br>\frac{(a * n + b) * (a * n + b + 1)}{2} \ % n &#x3D; (\frac{(a * n) * (a * n + 1)}{2} % n + \frac{b * (b + 1)}{2} % n) % n<br>$$<br>$~~~~$ 证明待补。<br>$~~~~$ 因此，$f &#x3D; a * n + b, b &lt; n$，枚举 $a$ 即可。</p><h3 id="python-代码-2"><a href="#python-代码-2" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, x, p = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    s = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    mp = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        s[i] = i*(i+<span class="number">1</span>)//<span class="number">2</span> % n</span><br><span class="line">        <span class="keyword">if</span> mp.__contains__(s[i]):</span><br><span class="line">            mp[s[i]] = <span class="built_in">min</span>(mp[s[i]], i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mp.update(&#123;s[i]: i&#125;)</span><br><span class="line">    ok = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        now = (<span class="number">2</span>*n-s[n]*a%n-x)%n</span><br><span class="line">        <span class="keyword">if</span> mp.__contains__(now) <span class="keyword">and</span> mp[now] + a*n &lt;= p:</span><br><span class="line">            ok = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ok:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;NO&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$ 给一个 $ n \times m , 4|m$ 的 $01$ 矩阵，对于每一行，满足两个连在一起的块数量和单个块的数量都为 $\frac{m}{4}$。<br>$~~~~$ 要求分配两种块的位置，使得至少有一个 $1$ 的块的数量最少或最多。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$ 显然每一行是独立的。记每一行 $1$ 的数量为 $ cnt1 $。<br>$~~~~$ 对于最小值，贪心的找每一行 $11$ 块数量 $ cnt11 $。  </p><ul><li>如果 $cnt11 \le \frac{m}{4}$，答案为 $cnt1 - 2 \times cnt11 + cnt11$   </li><li>如果 $cnt11 &gt; \frac{m}{4}$，答案为 $cnt1 - 2 \times \frac{m}{4} + \frac{m}{4}$</li></ul><p>$~~~~$ 对于最大值，贪心的找每一个不是 $11$ 块的数量 $cnt11n$。  </p><ul><li>如果 $cnt11 \le \frac{m}{4}$，则 $cnt11 &#x3D; \frac{m}{4} - cnt11n$，答案为 $cnt1 - 2 \times cnt11 + cnt11$   </li><li>如果 $cnt11 &gt; \frac{m}{4}$，则 $cnt11 &#x3D; \frac{m}{4} - cnt11n$, 答案为 $cnt1$</li></ul><h3 id="python-代码-3"><a href="#python-代码-3" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">mn, mx = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    cnt1 = s.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m:</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; m <span class="keyword">and</span> s[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> s[i+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    mn += cnt1 - <span class="built_in">min</span>(m//<span class="number">4</span>, x)</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m:</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; m <span class="keyword">and</span> (s[i] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> s[i] != s[i+<span class="number">1</span>]):</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    mx += cnt1 - <span class="built_in">max</span>(<span class="number">0</span>, (m//<span class="number">4</span> - x))</span><br><span class="line"><span class="built_in">print</span>(mn, mx)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, A, B, C, D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 143 (Rated for Div. 2) C - D</title>
    <link href="/2023/03/15/cf_1795/"/>
    <url>/2023/03/15/cf_1795/</url>
    
    <content type="html"><![CDATA[<p>C (二分) D (组合数学)</p><span id="more"></span><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/contest/1795">https://codeforces.com/contest/1795</a></p><h2 id="C-二分"><a href="#C-二分" class="headerlink" title="C (二分)"></a>C (二分)</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$给两个数组 $a$, $b$，进行 $n$ 轮操作，对于第 $k$ 次操作，$\forall i \in [1, n-k+1], a[i] -&#x3D; min(b[i+k-1], a[i])$，对第 $i+k-1$ 个答案产生 $min(b[i+k-1], a[i])$ 的贡献。  </p><p>$~~~~$求出所有的答案。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$反过来考虑每个 $a[i]$ 的贡献，对于 $b[j], j &gt;&#x3D; i$，它会对第 $j$ 个答案产生 $b[j]$ 的贡献，直到 $a[i] &lt;&#x3D; b[i] + b[i+1] + … + b[e]$ 未知，特别的， $a[i]$ 对第 $e$ 个答案产生的贡献为 $a[i] - b[i] - b[i+1] - … - b[e-1]$。  </p><p>$~~~~$因此我们可以先求出 $b$ 的前缀和 $sb$，要计算每个 $a[i]$ 的贡献，我们只需要在 $j \in [i, n]$ 范围二分找到 $sb[n] - sb[i-1] &gt;&#x3D; a[i]$ 的第一个数，即为 $e$。</p><h3 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">num, left, right</span>):</span><br><span class="line">    l, r = left, right</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> b[mid] &gt;= num:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = [<span class="number">0</span>] + [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    b = [<span class="number">0</span>] + [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    c = b.copy()</span><br><span class="line">    s = <span class="built_in">sum</span>(b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>]</span><br><span class="line">    f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">    g = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a[i] + b[i-<span class="number">1</span>] &gt;= b[n]:</span><br><span class="line">            f[i] += <span class="number">1</span></span><br><span class="line">            f[n+<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pos = lower_bound(a[i] + b[i-<span class="number">1</span>], i, n)</span><br><span class="line">        <span class="keyword">if</span> i != pos:</span><br><span class="line">            f[i] += <span class="number">1</span></span><br><span class="line">            f[pos] -= <span class="number">1</span></span><br><span class="line">        g[pos] += a[i] + b[i-<span class="number">1</span>] - b[pos-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        f[i] += f[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%d &#x27;</span> % (f[i] * c[i] + g[i]), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="D-组合数学"><a href="#D-组合数学" class="headerlink" title="D (组合数学)"></a>D (组合数学)</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$给出每三个点一组的完全图（三个点两两相连），一共有 $\frac{n}{3} (6|n)$ 组，要求对所有节点染色，一共有两种颜色（红、蓝），最终的染色方案必须满足两种颜色数量相同。  </p><p>$~~~~$在每一组中，若两个点的颜色不同，则对答案的贡献为两个点的边权。要求计算使得答案最大的染色方案的数量。模 $998244353$。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$要使答案最大，只需从每个组中选出两个最大的边权对答案产生贡献即可，因此每个组中的颜色必然满足存在两个颜色相同，不妨设三中颜色分别为 $x ~ x ~ y, (x &gt;&#x3D; y)$，对于每一组，只要 $y$ 确定了，则 $x$ 也就确定了。      </p><p>$~~~~$因此考虑 $y$，要使两种颜色数量相同，只需平均分配即可，即从 $\frac{n}{3}$ 个组中选 $\frac{n}{6}$ 个染成红色，其他 $\frac{n}{6}$ 个染成蓝色。因此答案为 $C(\frac{n}{3}, \frac{n}{6}) % mod$。  </p><p>$~~~~$考虑一下特殊情况：  </p><ul><li>当某一组 $y$ 的数量为 $2$ 时，$y$ 的位置可以选择两个与 $x$ 交汇处之一，因此对答案贡献 $*2$  </li><li>当某一组 $y$ 的数量为 $2$ 时，$y$ 的位置可以选择任意两个点交汇处之一，因此对答案贡献 $*3$</li></ul><h3 id="python-代码-1"><a href="#python-代码-1" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="number">1e5</span>)</span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">5</span>)]</span><br><span class="line">inv = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">5</span>)]</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">mod = <span class="number">998244353</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] * i % mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qmi</span>(<span class="params">a, b</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        <span class="keyword">if</span> b &amp; <span class="number">1</span>:</span><br><span class="line">            res = res * a % mod</span><br><span class="line">        a = a * a % mod</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inv[N] = qmi(f[N], mod - <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f[n] * inv[m] * inv[n - m] % mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, <span class="number">3</span>):</span><br><span class="line">    b = a[i:i + <span class="number">3</span>]</span><br><span class="line">    res = res * b.count(<span class="built_in">min</span>(b)) % mod</span><br><span class="line"><span class="built_in">print</span>(res * C(n//<span class="number">3</span>, n//<span class="number">6</span>) % mod)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, C, D, Educational Codeforces Round 143</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 857 (Div. 2) C - E</title>
    <link href="/2023/03/14/cf_1802_C_E/"/>
    <url>/2023/03/14/cf_1802_C_E/</url>
    
    <content type="html"><![CDATA[<p>C (构造) D (贪心、multiset) E (树状数组优化dp)</p><span id="more"></span><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/contest/1802">https://codeforces.com/contest/1802</a></p><h2 id="C-构造"><a href="#C-构造" class="headerlink" title="C (构造)"></a>C (构造)</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$构造一个 $n \times m$ 的矩阵，使得每一个 $2 \times 2$ 的子矩阵满足：<br>$$<br>\begin{matrix} A_{11} \oplus A_{12} \oplus A_{21} \oplus A_{22}&#x3D;A_{33}\oplus A_{34} \oplus A_{43} \oplus A_{44}<br> \A_{13} \oplus A_{14} \oplus A_{23} \oplus A_{24}&#x3D;A_{31}\oplus A_{32} \oplus A_{41} \oplus A_{42}<br>\end{matrix}<br>$$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$通过观察样例，可以猜想每一个子矩阵的异或和是一个常数。（待证明）  </p><p>$~~~~$因此，我们可以随机化矩阵的第一行和第一列，并设定一个常数 $C$ 作为每个子矩阵的异或和。对于一个子矩阵，若已知三个数的值 $A_{1}, A_{2}, A_{3}$，则第四个值 $A_{4}&#x3D;C \oplus A_{1} \oplus A_{2} \oplus A_{3}$。</p><h3 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mod = (<span class="number">1</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span></span><br><span class="line">f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    f[i][<span class="number">0</span>] = random.randint(<span class="number">0</span>, <span class="number">100000000000000012</span>)</span><br><span class="line">    f[<span class="number">0</span>][i] = random.randint(<span class="number">0</span>, <span class="number">100000000000000012</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):</span><br><span class="line">        f[i][j] = mod ^ f[i - <span class="number">1</span>][j] ^ f[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ f[i][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, m = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="built_in">print</span>(n*m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%d &#x27;</span> % f[i][j], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="D-贪心、multiset"><a href="#D-贪心、multiset" class="headerlink" title="D (贪心、multiset)"></a>D (贪心、multiset)</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$给出两个数组 $a, b$，操作 $n$ 次，对于第 $i$ 次，每次只能从 $a_{i}、b_{i}$ 中选出一个，记从 $a$ 随选出的数列为 $a_{choose}$，从 $b$ 中选出的数列为 $b_{choose}$，目标是最小化 $\left | \max(a_{choose}) - \max(b_{choose}) \right | $。  </p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$将 $a, b$ 一起按照 $a$ 从大到小排序，从前往后遍历 $a$，对于 $a_{i}$，将其作为从 $a$ 中选出的最大值。  </p><p>$~~~~$由于 $\forall j \in [1,i-1], a_{j} &lt; a_{i}$，因此，$i$ 前面的 $a$ 一定不选，$i$ 前面的 $b$ 一定要选；$i$ 后面的 $b$ 可选可不选。  </p><p>$~~~~$记 $mxb &#x3D; \max(b_{j}, j \in [1,i-1])$ ，则只需要在 $i$ 后面的 $b$ 中找到和 $a_{i}$ 最相近的且 $&gt; mxb$ 的数 $b_{k}$ 即可用 $\left | a_{i} - b_{k} \right |$ 更新答案；如果没有找到，则用 $\left | a_{i} - mxb \right |$ 更新答案。  </p><p>$~~~~$可用 $muliset$ 维护，$lower_bound$ 用于寻找最相近的数。 </p><p>$~~~~$时间复杂度 $O(nlogn)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _for( i, L, R ) for ( int i = L; i &lt;= R; ++i )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;( <span class="type">const</span> Node &amp; o ) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(a &gt; o.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;n );</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">_for( i, <span class="number">1</span>, n ) <span class="built_in">scanf</span>( <span class="string">&quot;%d%d&quot;</span>, &amp;e[i].a, &amp;e[i].b ), s.<span class="built_in">insert</span>( e[i].b );</span><br><span class="line"><span class="built_in">sort</span>( e + <span class="number">1</span>, e + n + <span class="number">1</span> );</span><br><span class="line"><span class="type">int</span> res = <span class="number">1e9</span>, mx = <span class="number">-1e9</span>;</span><br><span class="line">_for( i, <span class="number">1</span>, n )</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">erase</span>( s.<span class="built_in">find</span>( e[i].b ) );</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>( e[i].a );</span><br><span class="line"><span class="keyword">if</span> ( it != s.<span class="built_in">end</span>() <span class="keyword">and</span> * it &gt; mx )</span><br><span class="line">res = <span class="built_in">min</span>( res, <span class="built_in">abs</span>( e[i].a - *it ) );</span><br><span class="line"><span class="keyword">if</span> ( it != s.<span class="built_in">begin</span>() <span class="keyword">and</span> * <span class="built_in">prev</span>( it ) &gt; mx )</span><br><span class="line">res = <span class="built_in">min</span>( res, <span class="built_in">abs</span>( e[i].a - *<span class="built_in">prev</span>( it ) ) );</span><br><span class="line">res= <span class="built_in">min</span>( res, <span class="built_in">abs</span>( e[i].a - mx ) );</span><br><span class="line">mx= <span class="built_in">max</span>( e[i].b, mx );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, res );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;T );</span><br><span class="line"><span class="keyword">while</span> ( T-- )</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可用树状数组实现 $multiset$  </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _for(i, L, R) for (int i = L; i &lt;= R; ++i)</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tot, sz, INF;</span><br><span class="line"><span class="type">int</span> num[N], tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pos</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + sz, x) - num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (x; x &lt;= sz; x += x &amp; -x)</span><br><span class="line">tr[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (x; x; x -= x &amp; -x)</span><br><span class="line">tmp += tr[x];</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> rs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">rs += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"><span class="keyword">if</span> (rs &gt; sz || tr[rs] &gt;= x)</span><br><span class="line">rs -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x -= tr[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num[rs + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Q</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Q &amp;o) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; o.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x != INF <span class="keyword">and</span> x != -INF <span class="keyword">and</span> x &gt; mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sovle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line">INF = <span class="number">0</span>;</span><br><span class="line">_for(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;e[i].a, &amp;e[i].b), num[++tot] = e[i].a, num[++tot] = e[i].b;</span><br><span class="line">INF = <span class="built_in">max</span>(INF, e[i].a);</span><br><span class="line">INF = <span class="built_in">max</span>(INF, e[i].b);</span><br><span class="line">&#125;</span><br><span class="line">INF++;</span><br><span class="line">num[++tot] = -INF;</span><br><span class="line">num[++tot] = INF;</span><br><span class="line"><span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + tot);</span><br><span class="line">sz = <span class="built_in">unique</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + tot) - num - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(e + <span class="number">1</span>, e + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">pos</span>(-INF), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">pos</span>(INF), <span class="number">1</span>);</span><br><span class="line">_for(i, <span class="number">1</span>, n) <span class="built_in">add</span>(<span class="built_in">pos</span>(e[i].b), <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">mx = <span class="number">-1e9</span>;</span><br><span class="line">_for(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">pos</span>(e[i].b), <span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">kth</span>(<span class="built_in">query</span>(<span class="built_in">pos</span>(e[i].a) - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(x))</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - e[i].a));</span><br><span class="line">x = <span class="built_in">kth</span>(<span class="built_in">query</span>(<span class="built_in">pos</span>(x)));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(x))</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - e[i].a));</span><br><span class="line">x = <span class="built_in">kth</span>(<span class="built_in">query</span>(<span class="built_in">pos</span>(x)) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(x))</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - e[i].a));</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(e[i].a - mx));</span><br><span class="line">mx = <span class="built_in">max</span>(e[i].b, mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">pos</span>(-INF), <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="built_in">pos</span>(INF), <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)</span><br><span class="line"><span class="built_in">sovle</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="number">1e6</span> + <span class="number">5</span>)</span><br><span class="line">tot = sz = INF = mx = <span class="number">0</span></span><br><span class="line">vec = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">tr = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">es = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">l, r, x</span>):</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num[mid] &gt;= x:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pos</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> lower_bound(<span class="number">1</span>, sz, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, k</span>):</span><br><span class="line">    <span class="keyword">while</span> x &lt;= sz:</span><br><span class="line">        tr[x] += k</span><br><span class="line">        x += (x &amp; -x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x:</span><br><span class="line">        res += tr[x]</span><br><span class="line">        x -= (x &amp; -x)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kth</span>(<span class="params">x</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="keyword">if</span> res &gt; sz <span class="keyword">or</span> tr[res] &gt;= x:</span><br><span class="line">            res -= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x -= tr[res]</span><br><span class="line">    <span class="keyword">return</span> num[res + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x != INF <span class="keyword">and</span> x != -INF <span class="keyword">and</span> x &gt; mx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    tot = INF = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a, b = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">        es[i] = [a, b]</span><br><span class="line">        tot += <span class="number">1</span></span><br><span class="line">        vec[tot] = es[i][<span class="number">0</span>]</span><br><span class="line">        tot += <span class="number">1</span></span><br><span class="line">        vec[tot] = es[i][<span class="number">1</span>]</span><br><span class="line">        INF = <span class="built_in">max</span>(INF, <span class="built_in">max</span>(es[i]))</span><br><span class="line">    INF += <span class="number">1</span></span><br><span class="line">    tot += <span class="number">1</span></span><br><span class="line">    vec[tot] = -INF</span><br><span class="line">    tot += <span class="number">1</span></span><br><span class="line">    vec[tot] = INF</span><br><span class="line">    num = [<span class="number">0</span>] + <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(vec[<span class="number">1</span>: tot+<span class="number">1</span>])))</span><br><span class="line">    sz = <span class="built_in">len</span>(num) - <span class="number">1</span></span><br><span class="line">    e = <span class="built_in">sorted</span>(es[:n], key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    add(pos(-INF), <span class="number">1</span>)</span><br><span class="line">    add(pos(INF), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> e:</span><br><span class="line">        add(pos(b), <span class="number">1</span>)</span><br><span class="line">    res, mx = <span class="number">1e9</span>, -<span class="number">1e9</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> e:</span><br><span class="line">        add(pos(b), -<span class="number">1</span>)</span><br><span class="line">        x = kth(query(pos(a) - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> check(x):</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - a))</span><br><span class="line">        x = kth(query(pos(a)))</span><br><span class="line">        <span class="keyword">if</span> check(x):</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - a))</span><br><span class="line">        x = kth(query(pos(a)) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> check(x):</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(x - a))</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(mx - a))</span><br><span class="line">        mx = <span class="built_in">max</span>(b, mx)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    add(pos(-INF), -<span class="number">1</span>)</span><br><span class="line">    add(pos(INF), -<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-树状数组优化dp"><a href="#E-树状数组优化dp" class="headerlink" title="E (树状数组优化dp)"></a>E (树状数组优化dp)</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>$~~~~$给出 $n$ 个数组，每个数组有 $k_{i}$ 个数，找到一直数组拼接方式，使得拼接后的数组 $b$ 中满足 $\forall j \in [1, i-1], b_{i} &gt; b_{j}$ （条件1）的数最多。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>$~~~~$考虑dp。记<br>$$<br>f[i]：前 i 个数组拼接而成的最大答案<br>$$</p><ul><li>由于一个数组中可能对答案产生贡献的只有在本数组中满足条件1的数，因此在读入时即可使数组单调递增  </li><li>将 $n$ 个数组按照最后一个元素从小到大排序，这样在更新 $f[i]$ 时，前面的状态一定已经被更新完了  </li><li>对于 $f[i]$，其中的某一个数 $a_{i, j}$，贡献来自两部分<ul><li>由于 $\forall p \in [j+1, k_{i}], a_{i, p} &gt; a_{i, j}$，因此贡献为 $k_{i}-j$</li><li>对于最大值小于 $a_{i, j}$ 的数组 $a_{s}$，其贡献为 $\max(f[s])$</li></ul></li></ul><p>$~~~~$因此，状态转移方程为<br>$$<br>f[i] &#x3D; \max(\max(f[s]) + k_{i} - j), s &#x3D; {s| \max(a_{s}) &lt; a_{i, j}}<br>$$</p><p>$~~~~$其中，$\max(f[s])$ 可用树状数组维护。</p><p>$~~~~$时间复杂度 $O(nklogn)$</p><h3 id="c-代码"><a href="#c-代码" class="headerlink" title="c++ 代码"></a>c++ 代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3,<span class="string">&quot;Ofast&quot;</span>,<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _for( i, L, R ) for ( int i = L; i &lt;= R; ++i )</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">( <span class="type">int</span> x )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(x &amp; - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>n, tr[N], f[N], mxv;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">bool</span> operator&lt;( <span class="type">const</span> Node &amp; o ) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(v.back() &lt; o.v.back() );</span><br><span class="line">&#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> y )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = x; i &lt;= mxv; i += lowbit( i ) )</span><br><span class="line">tr[i] = max( tr[i], y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">( <span class="type">int</span> x )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = x; i; i -= lowbit( i ) )</span><br><span class="line">res = max( res, tr[i] );</span><br><span class="line"><span class="keyword">return</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">( <span class="type">int</span> x )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = x; i &lt;= mxv; i += lowbit( i ) )</span><br><span class="line">tr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;n );</span><br><span class="line">mxv = <span class="number">0</span>;</span><br><span class="line">_for( i, <span class="number">1</span>, n )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;m );</span><br><span class="line"><span class="keyword">while</span> ( m-- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;x );</span><br><span class="line"><span class="keyword">if</span> ( a[i].v.empty() or a[i].v.back() &lt; x )</span><br><span class="line">a[i].v.push_back( x ), mxv = max( mxv, x );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort( a + <span class="number">1</span>, a + <span class="number">1</span> + n );</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">_for( i, <span class="number">1</span>, n )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = a[i].v.size(), cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> j = k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j )</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">f[i] = max( f[i], cnt + query( a[i].v[j] - <span class="number">1</span> ) );</span><br><span class="line">&#125;</span><br><span class="line">modify( a[i].v.back(), f[i] );</span><br><span class="line">res = max( res, f[i] );</span><br><span class="line">&#125;</span><br><span class="line">_for( i, <span class="number">1</span>, n ) clear( a[i].v.back() ), a[i].v.clear(), f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d\n&quot;</span>, res );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;T );</span><br><span class="line"><span class="keyword">while</span> ( T-- )</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, C, D, E, Maximum Subarray, dp, DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 144 (Rated for Div. 2) D. Maximum Subarray (Dp)</title>
    <link href="/2023/03/12/cf_1796_D/"/>
    <url>/2023/03/12/cf_1796_D/</url>
    
    <content type="html"><![CDATA[<p>D (dp)</p><span id="more"></span><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://codeforces.com/contest/1796/problem/D">https://codeforces.com/contest/1796/problem/D</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>$~~~~$给一个数组 $a$，要求选出 $a$ 的一个长度为 $k$ 的子序列 $b_{1}, b_{2}, …, b_{k}$，让 $\forall i<br>\in [1, k], b_{i} +&#x3D; x$，而让 $\forall a_{i} \in a \ and \ a_{i} \notin b, a_{i} -&#x3D; x$，使得形成的新数组最大子段和最大。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$~~~~$考虑 DP。  </p><p>$~~~~$设 $f[i][j]$ : 考虑前 $i$ 个数，已经选择了 $j$ 个数执行 “$+x$” 操作的大子段和。</p><p>$~~~~$分类讨论：  </p><ul><li>$a[i]$ 不执行 “$+x$” 操作   <ul><li>必须满足 $i &gt; j$，因为如果 $i&#x3D;j$ 则意味着前 $i$ 个数全部执行了 “$+x$” 操作，因此 $a[i]$ 必须执行 “$+x$” 操作  </li><li>$a[i]$ 必须执行 “$-x$” 操作</li><li>$a[i]$ 单独作为一个子段和，即 $a[i] - x$</li><li>$a[i]$ 合并到 $[1, i-1]$ 的最大子段和中，即 $f[i-1, j] + a[i] - x$</li></ul></li><li>$a[i]$ 执行 “$+x$” 操作<ul><li>$a[i]$ 单独作为一个子段和，即 $a[i] + x$</li><li>$a[i]$ 合并到 $[1, i-1]$ 的最大子段和中，即 $f[i-1, j-1] + a[i] + x$</li></ul></li></ul><p>$~~~~$因此，状态转移方程为：<br>$$<br>f[i,j]&#x3D;\left{\begin{matrix}max(a[i]-x,f[i-1,j]+a[i]-x)\ \ j&lt;i<br> \max(a[i]+x, f[i-1, j-1]+a[i]+x)\ \ j &gt; 0<br>\end{matrix}\right.<br>$$</p><p>$~~~~$初始条件为：$f[0, 0] &#x3D; 0$</p><h1 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n, k, x = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    a = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    inf = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    f = [[-inf <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 当前已经使用的 &quot;+x&quot; 操作 j 最少为 k-(n-i)，即让 i 后面的数全部执行 &quot;+x&quot; 操作</span></span><br><span class="line">        <span class="comment"># 当前已经使用的 &quot;+x&quot; 操作 j 最多为 i，即让 i 前面的数全部执行 &quot;+x&quot; 操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>, k-(n-i)), <span class="built_in">min</span>(i, k)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; i:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(a[i-<span class="number">1</span>] - x, f[i-<span class="number">1</span>][j] + a[i-<span class="number">1</span>] - x)</span><br><span class="line">            <span class="keyword">if</span> j:</span><br><span class="line">                <span class="comment"># 注意此处 f[i][j] 可能已经被更新，因此要带上</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], <span class="built_in">max</span>(a[i-<span class="number">1</span>] + x, f[i-<span class="number">1</span>][j-<span class="number">1</span>] + a[i-<span class="number">1</span>] + x))</span><br><span class="line">            <span class="comment"># 若只考虑当前的最大子段和，其他的 &quot;+x&quot; 操作发生在什么地方对当前结果没有影响</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, f[i][j])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, cf, D, Maximum Subarray, dp, DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 856 (Div. 2) a - D</title>
    <link href="/2023/03/11/cf_1794/"/>
    <url>/2023/03/11/cf_1794/</url>
    
    <content type="html"><![CDATA[<p>A (思维) B (思维) C (思维) D (dp) </p><span id="more"></span><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://codeforces.com/contest/1794">https://codeforces.com/contest/1794</a></p><h1 id="A-思维"><a href="#A-思维" class="headerlink" title="A (思维)"></a>A (思维)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$~~~~$给出一个字符串 $s$ 的所有子串 $s_{sub}$ 的随机排列，判断这个字符串 $s$ 是否为回文串</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$~~~~$找出两个长度最长的子串 $s_{sub, max_{1}}$、$s_{sub, max_{2}}$，假设 $s_{sub, max_{1}}$ 是 $s$ 的前缀，$s_{sub, max_{2}}$是 $s$ 的后缀，则<br>$$<br>s &#x3D; s_{sub, max_{1}}[:] + s_{sub, max_{2}}[-1] \ \ or \  \ s_{sub, max_{1}}[0] + s_{sub, max_{2}}[:]<br>$$</p><p>$~~~~$枚举两者情况即可求得 $s$，最后判断 $s$ 是否为回文串即可。</p><h2 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        res = s[<span class="number">0</span>] + s[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mxs = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(c) == n-<span class="number">1</span>:</span><br><span class="line">                mxs.append(c)</span><br><span class="line">        <span class="comment"># print(mxs[0][:n-2], mxs[1][1:])</span></span><br><span class="line">        <span class="keyword">if</span> mxs[<span class="number">0</span>][:n-<span class="number">2</span>] == mxs[<span class="number">1</span>][<span class="number">1</span>:]:</span><br><span class="line">            res = mxs[<span class="number">1</span>][<span class="number">0</span>] + mxs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = mxs[<span class="number">0</span>][<span class="number">0</span>] + mxs[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> res == res[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;YES&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;NO&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="B-思维"><a href="#B-思维" class="headerlink" title="B (思维)"></a>B (思维)</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>$~~~~$给一个数组 $a$，每一次操作可以让 $a_{i}&#x3D;a_{i}+1$，最多操作 $n$ 次，要求最后使得 $a$ 满足<br>$$<br>\forall i \in [1, n-1], a_{i} \ not\  \mid a_{i+1}<br>$$</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>$~~~~$贪心即可。 </p><p>$~~~~$从前往后遍历，只要 $a_{i-1} \mid a_{i}$，因为 $a_{i-1}+1$ 可能是 $a_{i}$ 的因子，而 $a_{i-1}$ 不可能是 $a_{i}+1$ 的因子，因此就让 $a_{i} +&#x3D; 1$。 </p><p>$~~~~$注意，当 $a_{i-1}&#x3D;1$ 时，恒有 $a_{i-1} | (a_{i}+1)$，因此如果 $\exists k \in [1, n], a_{k}&#x3D;1$，则使 $a_{k} +&#x3D; 1$。</p><h2 id="python-代码-1"><a href="#python-代码-1" class="headerlink" title="python 代码"></a>python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> a:</span><br><span class="line">        a = [_ + <span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> a]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> a[i] % a[i-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            a[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%d &#x27;</span> % x, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h1 id="C-思维"><a href="#C-思维" class="headerlink" title="C (思维)"></a>C (思维)</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>$~~~~$给一个单调非减数组 $a$，$\forall i \in [1, n]$，在 $a_{j}, j \in [1, i]$ 中选出一个子序列 $s_{1}, s_{2}, …, s_{d}$，要使 $maxsocre_{i} &#x3D; \frac{s_{1}<em>s_{2}</em>…*s_{d}}{d!} $，输出 $score_{i}$。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>$~~~~$注意到，$a$ 是一个单调非减的序列，且对于 $score &#x3D; \frac{s_{1}<em>s_{2}</em>…*s_{d}}{d!}$，如果想要加入一个数 $s_{d+1}$，则 $socre *&#x3D; \frac{s_{d+1}}{d+1}$。 </p><p>$~~~~$因此对于某一个前缀 $a_{j}, j \in [1, i]$，我们可以这样让 $score$ 最大化：</p><ul><li>$score &#x3D; a_{j}$ </li><li>$if a_{j-1}&#x2F;2 &gt; 1，则score &#x3D; \frac{a_{j} * a_{j-1}}{2}$ </li><li>依次类推</li></ul><p>$~~~~$因此，我们可以从前往后扫，用一个队列来维护 $score$ 的最大值，每次只需要判断队列前面的是否需要删除即可。</p><h2 id="python-代码-2"><a href="#python-代码-2" class="headerlink" title="python 代码"></a>python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">    res, l, r = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    que = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">        que[r] = x</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> que[l] &lt; res <span class="keyword">and</span> l &lt; r:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%d &#x27;</span> % res, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h1 id="D-dp"><a href="#D-dp" class="headerlink" title="D (dp)"></a>D (dp)</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>$~~~~$给出一个长度为 $2n$ 的数组 $a$，$a$ 的某一个排列是某一个数的质因数分解，即<br>$$<br>f(m) &#x3D; {p_{1}, e_{1}, p_{2}, e_{2}, …, p_{k}, e_{k}}<br>$$</p><p>$~~~~$求有多少个这样的数，模 $998244353$。</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>$~~~~$首先考虑特殊情况，当 $a$ 中的素数数量 $&lt;n$ 时，答案显然为 $0$。</p><p>$~~~~$注意到，当选定 $n$ 个数为底数时，剩下的 $n$ 个数做全排列。设 $a$ 去重后为 $b$，由多重集全排列理论可知，全排列数为<br>$$<br>\frac{n!}{cnt_{b_{1}}! * cnt_{b_{2}}! * .. cnt_{b_{m}}!}<br>$$</p><p>$~~~~$其中 $cnt_{b_{k}}$ 是 $b_{k}$ 的数量。</p><p>$~~~~$当 $b_{k}$ 为非素数时，贡献是固定的，因为它们都不能作为底数。而当 $b_{k}$ 为素数时，贡献是不固定的，因为当它们作为底数时，贡献为 $\frac{1}{(cnt_{b_{k}}-1)!}$，而这个部分可以用 $dp$ 来求。</p><p>$~~~~$设 $f_{i, j}$ 为处理到第 $i$ 种数，以 $j$ 个数作为底数时的贡献。考虑如何从 $f_{i-1}$ 转移：</p><ul><li>当第 $i$ 种数不作为底数时，则 $f_{i,j} &#x3D; \frac{f_{i-1, j}}{cnt_{b_{i}}!} $，因为前后的底数数量 $j$ 是一样的</li><li>当第 $i$ 种数作为底数时，则 $f_{i,j} &#x3D; \frac{f_{i-1,j-1}}{(cnt_{b_{i}}-1)!}$，因为当前比上一次多一个底数<br>$f_{m, n}$ 即为素数的贡献，其中 $m$ 是数的种类。</li></ul><p>$~~~~$最后，设 $b$ 中的非素数部分为 $c$，则<br>$$res &#x3D; \frac{n}{cnt_{c_{1}}! * cnt_{c_{2}}! *…} * f_{m, n}<br>$$</p><h2 id="c-代码"><a href="#c-代码" class="headerlink" title="c++ 代码"></a>c++ 代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">primes</span><span class="params">(mx + <span class="number">1</span>)</span>, <span class="title">not_prime</span><span class="params">(mx + <span class="number">1</span>)</span></span>;</span><br><span class="line">    not_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt_primes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!not_prime[i]) primes[++cnt_primes] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt_primes <span class="keyword">and</span> i * primes[j] &lt;= mx; j++) &#123;</span><br><span class="line">            not_prime[i * primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = <span class="built_in">qmi</span>(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p, np;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(not_prime[a[i]]) np.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            <span class="keyword">else</span> p.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &lt; n) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = fac[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; np.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        res = (<span class="type">long</span> <span class="type">long</span>)res * inv[cnt[np[i]]] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = (<span class="type">long</span> <span class="type">long</span>)f[i - <span class="number">1</span>][<span class="number">0</span>] * inv[cnt[p[i - <span class="number">1</span>]]] % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i][j] = ((<span class="type">long</span> <span class="type">long</span>)f[i - <span class="number">1</span>][j] * inv[cnt[p[i - <span class="number">1</span>]]] % mod + (<span class="type">long</span> <span class="type">long</span>)f[i - <span class="number">1</span>][j - <span class="number">1</span>] * inv[cnt[p[i - <span class="number">1</span>]] - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (<span class="type">long</span> <span class="type">long</span>)res * f[p.<span class="built_in">size</span>()][n] % mod;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>codeforce, Codeforces Round 856 (Div. 2) A - D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Hexo 配置博客</title>
    <link href="/2023/03/09/%E4%BD%BF%E7%94%A8hexo%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/03/09/%E4%BD%BF%E7%94%A8hexo%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><p><code>npm install -g hexo-cli</code></p><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>查看默认安装路径 <code>npm config ls</code>，找到 <code>hexo-cli/bin</code>文件夹，将其添加到环境变量中  </p><h1 id="创建新文件夹"><a href="#创建新文件夹" class="headerlink" title="创建新文件夹"></a>创建新文件夹</h1><p><code>mkdir blog</code></p><h1 id="hexo-初始化"><a href="#hexo-初始化" class="headerlink" title="hexo 初始化"></a><code>hexo</code> 初始化</h1><p><code>hexo init</code></p><!-- # <code>hexo g</code># 棰勮<code>hexo s</code># 閮ㄧ讲<code>hexo d</code> -->]]></content>
    
    
    
    <tags>
      
      <tag>hexo, blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
